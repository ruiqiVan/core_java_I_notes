# 4.3.1Employee类
最简单的定义方式  

class ClassName{
    field1;
    field2;
    constructor1;//构造器1
    constructor2;//构造器2
    method1;//方法1
    method2;//方法2
}


```` java
class Employee {
    //实例字段(c++中称为成员变量)
   private String name;
   private double salary;
   private LocalDate hireDay;

    //构造器这里只有一种，但可以重载
   public Employee(String n, double s, int year, int month, int day) {
      name = n;
      salary = s;
      hireDay = LocalDate.of(year, month, day);
   }

    //各种方法
   public String getName() {
      return name;
   }

   public double getSalary() {
      return salary;
   }

   public LocalDate getHireDay() {
      return hireDay;
   }

   public void raiseSalary(double byPercent) {
      double raise = salary * byPercent / 100;
      salary += raise;
   }
}
````

# 4.3.4刨析Employee类
该类的所有实例字段:  
   private String name;  
   private double salary;  
   private LocalDate hireDay;  
   都标记了**private**,代表只有Employee类自身可以访问这些，一般都推荐将实例字段标记为private,以维护类的封装性

上面类的所有方法前都加上了**public**,代表这些方法可以被其他类调用(前提是创建Employee对象)

  
# 4.3.4从构造器开始
```` java
 public Employee(String n, double s, int year, int month, int day) {
      name = n;
      salary = s;
      hireDay = LocalDate.of(year, month, day);
   }
````
可以看到,构造器必须与类名相同,在构造Employee类对象时,构造器会将实例的name赋值为n,salary赋值为s,hireDay也会调用相应的构造器.  

注意,构造器必须和new方法使用,在创造好一个对象后再调用会产生编译错误.
```` java
        Employee james = new Employee("James Bond", 100000, 1950, 1, 1);
        // james.Employee("James Bond", 200000, 1950, 1, 1);//error
````
现在我们记住:  
1. 构造器与类同名
2. 每个类可以有一个以上的构造器(重载),当然也可能没有,比如之前的LocalDate类
3. 构造器可以有0个,1个或多个参数
4. 构造器没有返回值,当然也不是void类型,构造器名称前不能加void
5. 伴随new调用
  
c++注释:  
c++中我们可以这样创造对象:  
Employee james = new Employee("James Bond", 100000, 1950, 1, 1);  
但java中我们不行,因为java中对象变量更像c++中对象指针  
即在java中Employee james = new Employee("James Bond", 100000, 1950, 1, 1);   
这句话相当于在c++中的Employee * james = new Employee("James Bond", 100000, 1950, 1, 1);




最好不要再构造器中定义与示例字段相同的变量或者构造器中参数的名字与类实例字段相同
```` java
import java.time.LocalDate;

class Employee {
    private String name;
    private var zero=0;
    private double salary;
    private LocalDate hireDay;

    public Employee(String n, double s, int year, int month, int day) {
        String name = n;
        double salary = s;
        LocalDate hireDay = LocalDate.of(year, month, day);
    }

    public Employee(double salary, int year, int month, int day) {
        name = "unknown";
        salary = salary;
        hireDay = LocalDate.of(year, month, day);
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }
}

public class EmployeeTest {
    public static void main(String[] args) {
        Employee james = new Employee("James Bond", 100000, 1950, 1, 1);
        System.out.println(james.getName());//会打印null

        Employee number007 = new Employee(23333, 1950, 1, 1);
        System.out.println(number007.getSalary());//0.0
    }
}
````
这是一段比较糟糕的代码,观察它们的构造器
1. ```` java
    public Employee(String n, double s, int year, int month, int day) {
        String name = n;
        double salary = s;
        LocalDate hireDay = LocalDate.of(year, month, day);
    }
    ````
这个构造器中新创造了局部变量name,salary,hireDay遮蔽了同名的实例字段(编译器无法报错,因为这三个和实例字段作用域不同,这三个作用域是构造器内,实例字段为当前对象内) 

2. ```` java
    public Employee(double salary, int year, int month, int day) {
        name = "unknown";
        salary = salary;
        hireDay = LocalDate.of(year, month, day);
    }
   ````
这里没有创建新的局部变量,但是构造器参数与实例重名,实例字段仍会被遮蔽  
但是这样有种方法解决
```` java
    public Employee(double salary, int year, int month, int day) {
        this.name = "unknown";
        this.salary = salary;
        this.hireDay = LocalDate.of(year, month, day);
    }
   ````
**this**指示当前对象,也就是说在执行  
Employee number007 = new Employee(23333, 1950, 1, 1);这句话构造器在执行时this.salary=salary相当于number007.salary=salary也就是说不会被遮蔽  

# 4.3.5 用var声明局部变量
从java10开始,可以用var关键字声明局部变量,从而无须指定类型
**var** harry = new Employee("Harry Hacker", 5000, 1989, 10, 1);  
这句话JVM(Java Virtual Machine,java虚拟机)会自动推断出harry为Employee类型.当然不推荐对数值型使用var,否则对var类型赋值时0,0L,0.0的区别带来的问题可能会给你带来疑惑

var关键字再用于声明变量时,必须同时赋值
如var str="2233",这是正确的  
但如果不声明,var str;这是不正确的,因为JVM无法确定str类型。并且在方法的参数中一般不能使用var
```` java
    public Employee(var n, double s, int year, int month, int day) {
        String name = n;
        double salary = s;
        LocalDate hireDay = LocalDate.of(year, month, day);
    }
   ````
这里也是error,n的类型JVM无法确定

# 4.3.6使用null引用
```` java
    public Employee(String n, double s, int year, int month, int day) {
        name = n;
        salary = s;
        hireDay = LocalDate.of(year, month, day);
    }
````
这里n可以传null,而对null应用一个方法，会返回NullPointerException异常.我们有两种解决方法，均需import java.util.Objects;

1. 宽容型
将null值设为一个非null值,java9提供了一个方法
```` java
    public Employee(String n, double s, int year, int month, int day) {
       //如果n不为null返回n，否则赋值name为"unknown"
        name =Objects.requireNonNullElse(n,"unknown") ;
        salary = s;
        hireDay = LocalDate.of(year, month, day);
    }
````
2. 严格型
直接拒绝null参数
```` java
    public Employee(String n, double s, int year, int month, int day) {
       //当n为null，程序退出，并打印The name cannot be null
        Objects.requireNonNull(n, "The name cannot be null");
        name = n;
        salary = s;
        hireDay = LocalDate.of(year, month, day);
    }
````


# 4.3.7隐式参数与显式参数
类的每一个非静态方法都有一个隐式参数,关键字this指示隐式参数，表示当前执行方法应用于的对象
```` java
    public Employee(double salary, int year, int month, int day) {
        this.name = "unknown";
        this.salary = salary;
        this.hireDay = LocalDate.of(year, month, day);
    }
   ````
**this**指示当前对象,也就是说在执行  
Employee number007 = new Employee(23333, 1950, 1, 1);在构造器执行时this.salary=salary相当于number007.salary=salary,而Salary,year,month,day为显示参数,使用this可以将实例字段与局部变量区分开,也是一种风格

c++注释:
c++类的成员函数可以在类外声明,类中定义则自动成为内联(inline)函数,java中所有方法必须在类中定义,是否设置内联是JVM的任务

# 4.3.8封装的优点
保护字段免受外界破坏.当需要获得或设置实例字段值是,需要提供:
1. 一个私有(private)数据字段
2. 一个公共(public)的字段访问器方法(方法名称可以包含get)
3. 一个公共(public)的字段更改器方法(方法名可以包含set)

警告:不要编写返回可变对象引用的方法(可变对象:对象中有方法可以改变对象的实例字段)
``` java
class Employee{
   private Date hireDay;
   ...
   public Date getHireDay(){
      return hireDay;
   }
}
````
LocalDate对象是不可变,但是Date可变,这破坏了封装性
比如Employee harry=...;  
Date d=harry.getHireDay();
d.setTime(d.getTime()-1000)//setTime为更改器方法,可以修改本身

如果需要返回一个可变对象的话,可以克隆(clone)，返回副本
``` java
class Employee{
   private Date hireDay;
   ...
   public Date getHireDay(){
      return hireDay.clone();
   }
}
````
![](https://cdn.jsdelivr.net/gh/RuiqiVan/core_java_I_img/res/unit4/return_reference.png)

# 4.3.9 基于类的访问权限


# 4.3.10私有方法 && 4.3.11final字段
将方法前的public改为private即可



