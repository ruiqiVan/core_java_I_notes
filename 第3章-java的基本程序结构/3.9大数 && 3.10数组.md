# 3.9大数
当基本的整形和浮点型满足不了需求，比如整数过大时，可以使用java.math中的两个类:BigInteger BigDecimal
##BigInteger
```` java
import java.math.BigInteger;

public class BigIntegerTest {
    public static void main(String[] args) {
        String num = "9223372036854775807";

        BigInteger a = BigInteger.valueOf(1);// 可以使用静态方法将数字转换为大数对象
        BigInteger b = new BigInteger(num);// 也可以用参数为字符串的构造器生成一个大数对象

        System.out.println(a.add(b));// 9223372036854775808
        System.out.println(a);// 输出仍然为1,add方法会返回一个新的BigInteger对象，不会修改原来对象

    }
}
````
各种API
BigInteger add(BigInteger other)//加 
BigInteger subtract(BigInteger other)//减 
BigInteger multiply(BigInteger other)//乘 
BigInteger divide(BigInteger other)//除 
BigInteger mod(BigInteger other)//求余数 
BigInteger sqrt()//返回该数平方根 
int compare(BigInterger)//如果该大数与other值相等返回0，小于返回负数，大于返回正数 
static BigInter valueOf(long x)//返回值等于x的大数 

___
##BigDecimal
而java.math.Decimal适用于浮点数
```` java
import java.math.BigDecimal;

public class BigDecimaTestl {

  public static void main(String[] args) {

    /* double sum = 0.0;
    while (sum != 1.0) {
      sum += 0.1;
    } */
    //单纯的浮点数运算会陷入死循环，而BigDecimal的精确度是够的
    BigDecimal sum_num = BigDecimal.valueOf(0.0);
    while (sum_num.doubleValue() != 1.0) {
      sum_num = sum_num.add(BigDecimal.valueOf(0.1));
    }
    System.out.print("success!");
  }
}

````
各种API
BigDecimal add(BigDecimal other)//加 
BigDecimal subtract(BigDecimal other)//减 
BigDecimal multiply(BigDecimal other)//乘 


BigDecimal divide(BigDecimal other)//1 
BigDecimal divide(BigDecimal other,RoundingMode mode)//2  
如果商是一个无限循环小数，则1会抛出一个异常，要得到舍入结果，就要使用第二种方法