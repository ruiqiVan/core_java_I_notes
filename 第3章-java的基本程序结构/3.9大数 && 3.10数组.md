# 3.9大数
当基本的整形和浮点型满足不了需求，比如整数过大时，可以使用java.math中的两个类:BigInteger BigDecimal
##BigInteger
```` java
import java.math.BigInteger;

public class BigIntegerTest {
    public static void main(String[] args) {
        String num = "9223372036854775807";

        BigInteger a = BigInteger.valueOf(1);// 可以使用静态方法将数字转换为大数对象
        BigInteger b = new BigInteger(num);// 也可以用参数为字符串的构造器生成一个大数对象

        System.out.println(a.add(b));// 9223372036854775808
        System.out.println(a);// 输出仍然为1,add方法会返回一个新的BigInteger对象，不会修改原来对象

    }
}
````
各种API
BigInteger add(BigInteger other)//加    
BigInteger subtract(BigInteger other)//减  
BigInteger multiply(BigInteger other)//乘   
BigInteger divide(BigInteger other)//除   
BigInteger mod(BigInteger other)//求余数   
BigInteger sqrt()//返回该数平方根   
int compare(BigInterger)//如果该大数与other值相等返回0，小于返回负数，大于返回正数   
static BigInter valueOf(long x)//返回值等于x的大数   

___
##BigDecimal
而java.math.Decimal适用于浮点数
```` java
import java.math.BigDecimal;

public class BigDecimaTestl {

  public static void main(String[] args) {

    /* double sum = 0.0;
    while (sum != 1.0) {
      sum += 0.1;
    } */
    //单纯的浮点数运算会陷入死循环，而BigDecimal的精确度是够的
    BigDecimal sum_num = BigDecimal.valueOf(0.0);
    while (sum_num.doubleValue() != 1.0) {
      sum_num = sum_num.add(BigDecimal.valueOf(0.1));
    }
    System.out.print("success!");
  }
}

````
各种API
BigDecimal add(BigDecimal other)//加     
BigDecimal subtract(BigDecimal other)//减  
BigDecimal multiply(BigDecimal other)//乘    



BigDecimal divide(BigDecimal other)//1 
BigDecimal divide(BigDecimal other,RoundingMode mode)//2  
如果商是一个无限循环小数，则1会抛出一个异常，要得到舍入结果，就要使用第二种方法,第二种方法中第二个参数为舍入方式，如RoundingMode.HALF_UP就是四舍五入 
int compare(BigDecimal other)//相等返回0，大于other返回正数，小于other返回负数 
 

static BigDecimal valueOf(long x)
static BigDecimal  valueof(long x,int scale)
返回值等于x或x/10^scale的一个大实数

#3.10数组
## 3.10.1声明数组
数组类型(类型名后紧跟[])+数组变量名 
如：int[] a; 
不过这只是声明，真正初始化需要new 操作,如int[] a=new int[n];就是声明并初始化了长度为n的数组
```` java
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("数组长度:");
        int n = in.nextInt();
        int[] a = new int[n];
        //a.length为数组长度，new初始的数组默认值为0
        for (int i = 0; i < a.length; i++) {
            System.out.println(a[i]);
        }
        in.close();
    }
}
````
注释：有两种声明风格，一种是int[] a;另一种是int a[]; 
还有列表初始化的初始方式 
如 int[] smallPrimes={2,3,4,6}; 
这种方式不需要new,当然最后一个值后面允许有逗号，如int int[] smallPrimes={2,3,4,6,};  

你还可以声明一个**匿名数组**，如 new int[]{1,2,3}(叫匿名数组是因为这个数组没有变量名，但确实存在)，可以用这个重新初始化一个数组，而不用创建新变量 
smallPrimes=new int[]{17,19,23,29}; 


注释：java中数组长度允许为0，如int a=new int[0],这样a.length会返回0，但空数组并不等于null，null是没办法调用数组的各种方法的。 

## 3.10.2访问数组元素
数组下标从0开始,如int []a=new int[100],那么你可以用下标访问的元素为(a[0]~a[99])
创建数字类型数组时，**整数型数组**或默认初始化为**0**，**浮点数数组**会默认初始化为**0.0**，**boolean数组**会默认初始化为**false**，**对象数组**的元素则初始化为一个特殊值**null**，表示还没有存放任何对象
```` java
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);
        System.out.print("数组长度:");
        int n = in.nextInt();
        String[] names = new String[10];
        for (int i = 0; i < names.length; i++) {
            System.out.println(names[i]);// 会全部打印null
        }
        in.close();
    }
}
````

## 3.10.3for each循环
增强的for循环语句格式为
for(variable :collection)statement 
用一个变量variable来存储集合中每一元素，并执行statement中的语句。collection这一个集合必须是一个**数组**或实现了**Iterable**接口的类对象(比如ArrayList,当然String没有实现)
```` java
import java.util.Arrays;
public class Test {
    public static void main(String[] args) {

        //error,String没实现Iterable接口
        /* String str = "3213";
        for (char temp : str) {
            System.out.println(temp);
        } */

        int[] a = { 3, 2, 1, 5, 6 };
        int sum = 0;
        for (int temp : a) {
            sum += temp;
        }
        //Arrays类的toString方法会返回一个包含数组元素的字符串
        System.out.println(Arrays.toString(a)+"总和为"+sum);//[3, 2, 1, 5, 6]总和为17 
    }
}
````
注释：这种for each循环语句不是根据下标值遍历数组，如果你想根据下标值来使用数组时，最好还是用传统的for循环  


## 3.10.4数组拷贝
默认为浅拷贝，即两个变量会引用同一个数组，  
如果希望将一个数组所有值拷贝到一个新的数组中去，可以使用Arrays类的copyOf对象 
```` java
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {

        int[] smallPrimes = { 2, 3, 5, 7, 11, 12 };
        int[] luckyNumbers = smallPrimes;

        // 修改luckyNumber[0],则smallPrimes也会改变，因为他们指向同一块内存
        luckyNumbers[0] = 233;
        System.out.println(smallPrimes[0]);// 会输出233

        int[] copiedNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length);

        // 这时修改copiedNumbers的值,luckyNumbers不会被修改
        copiedNumbers[0] = 114514;
        System.out.println("copiedNumber[0]为" + copiedNumbers[0] + " luckyNumbers[0]为" + luckyNumbers[0]);
        // copiedNumber[0]为114514,luckyNumbers[0]为233

        // 新数组长度大于原来长度，则如果为数值型额外元素为0(或0.0),boolean为false,对象为null
        System.out.println(copiedNumbers[copiedNumbers.length - 1]);// copiedNumbers[copiedNumbers.length-1]为数组最后一个元素，这里为0
    }
}
````
![拷贝一个数组变量](https://cdn.jsdelivr.net/gh/RuiqiVan/core_java_I_img/res/unit3/Copy_an%20_array%20.png)

##3.10.6数组排序
对数值型进行排序，可以使用Arrays类中的sort方法:  
int []a=new int[100];  
Arrays.sort(a);  

 
 下面的程序是从1,2,3...n中抽取k个数字并排序打印
```` java
import java.util.*;

/**
 * This program demonstrates array manipulation.
 * 
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */
public class LotteryDrawing {
   public static void main(String[] args) {
      Scanner in = new Scanner(System.in);

      System.out.print("你需要抽多少个数字? ");
      int k = in.nextInt();

      System.out.print("数字的最大值为? ");
      int n = in.nextInt();

      // fill an array with numbers 1 2 3 . . . n
      int[] numbers = new int[n];
      for (int i = 0; i < numbers.length; i++)
         numbers[i] = i + 1;

      // draw k numbers and put them into a second array
      int[] result = new int[k];
      for (int i = 0; i < result.length; i++) {
         // make a random index between 0 and n - 1
         int r = (int) (Math.random() * n);

         // pick the element at the random location
         result[i] = numbers[r];

         // move the last element into the random location
         numbers[r] = numbers[n - 1];
         n--;
      }

      // print the sorted array
      Arrays.sort(result);
      System.out.println("Bet the following combination. It'll make you rich!");
      for (int r : result)
         System.out.println(r);

      in.close();

   }
}
````
API
![Arrays常用API](https://cdn.jsdelivr.net/gh/RuiqiVan/core_java_I_img/res/unit3/Arrays_API1.png)
![Arrays常用API](https://cdn.jsdelivr.net/gh/RuiqiVan/core_java_I_img/res/unit3/Arrays_API2.png)


##3.10.7 多维数组
如果要在java中存储表格中数据或矩阵的数据的话，一维数组很难表示，但可以利用多维数组  
如 int[][] a=new int[2][3];就创造了一个二维数组，数组由**2**个一维数组组成，每个一维数组长度为**3**   
当然，你也可以直接初始化   
int [][]magicSquare={{16,3,2,13},{5,18,11,8}};  
而访问的话，二维数组用两个中括号访问,如magicSquare[0][0]代表magicSquare中第一个数组第一个元素

````  java
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        double[][] a = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
        double sum = 0.0;

        //for each语句不能自动处理二维数组每一个元素，它会循环处理行，要访问单一元素，你要使用嵌套循环
        for (double[] row : a) {
            for (double temp : row) {
                sum += temp;
            }
        }
        System.out.print("二维数组"+Arrays.deepToString(a)+"总和为" + sum);//可以使用Arrays.deepToString()打印元素
    }
}

````

## 3.10.8不规则数组
java声明二维数组，如 
double[][] balances=new double[10][16]; 
在c++中相当于double ** balances=new double* [10]//先分配一个包括十个指针的数组 
再for(int i=0;i<10;i++){
  balances[i]=new double[6]//让每个指针指向一个长度为6的数组
} 
所以我们可以构建一个不规则的"数组"，即数组每一行有一个不同长度
```` java
import java.util.Scanner;
import java.util.Arrays;

//打印row行杨辉三角
public class Yanghui_triangle {
    public static void main(String[] args) {
        int row;
        Scanner in = new Scanner(System.in);
        System.out.print("输入行数:");
        row = in.nextInt();

        int[][] triangle = new int[row][];
        for (int i = 0; i < row; i++) {
            triangle[i] = new int[i + 1];//每行长度为i+1
        }

        triangle[0][0] = 1;
        for (int i = 1; i < row; i++) {
            triangle[i][0] = 1;
            for (int j = 1; j < i; j++) {
                triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
            }
            triangle[i][i] = 1;
        }

        for (int i = 0; i < row; i++) {
          //每一行都是数组，可以调用方法打印
            System.out.println(Arrays.toString(triangle[i]));
        }
        in.close();
    }
}
````