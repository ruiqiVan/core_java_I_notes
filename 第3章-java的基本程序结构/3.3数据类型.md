# 3.3.1整型  
|  类型  |  字节大小  |  取值范围  |  
|:---:|:---:|:---:|  
|**byte**|**1字节**|-128~127|  
|**short**|**2字节**|-32768~32767|  
|**int**|**4字节**|-2147483648~2147483647(20亿左右)|
|**long**|**8字节**|-2^64~2^64-1|  
  
长整形(long)数值后面有**后缀字母L或l**(L的大小写均可),代表运算时这个数字作为long型运算(如2147483648(int型最大值,整数不加后缀或强制转换类型默认以int型运算)+1得出的结果是-2147483648)  
而2147483648+1L便是正确结果  
八进制有一个**前缀数字0**,比如011便是十进制9.十六进制有**前缀0x或0X**,如0x11便是十进制17  
从java7开始加上**前缀0b或0B**表示二进制,如0b11代表十进制3
还可以为数字字面量加上下划线,如int a=11_22,这里a声明复制后值为1122,加上下划线后只是方便阅读  
  
ps:不同于c++,java没有无符号(unsigned)形式的类型(无符号类型可以理解为一个类型数字值全部大于等于0)

# 3.3.2浮点类型
|  类型  |  字节大小  |  取值范围  |  
|:---:|:---:|:---:|  
|**float**|**4字节**|-3.40E+38 ~ +3.40E+38(有效位数6~7位)|
|**double**|**8字节**|-1.79E+308 ~ +1.79E+308(有效位数15位)|   

浮点数后面加f或F代表float型数值(如3.14F),浮点数默认为double型(也可以加后缀D或d,如3.14d)  
可以用16进制表示浮点值如1.875表示为0xFp-3(F为尾数,-3为指数,尾数采用16进制,指数采用10进制,指数计算为2,所以0xFp-3用十进制表示为15*2^-3)


---
有三个特殊浮点值:  
正无穷大  
负无穷大  
NaN(Not a Number)不是一个数字  
可以分别用Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,Double.NaN
来表示他们(这三个常量在java.lang.Double中,float中也有类似)
但你不能直接检测一个数是不是NaN(正无穷,负无穷可以)    
比如  
>double a= Double.NaN;  
System.out.println(a==Double.NaN)  

输出是false,而不是true,但是Double.isNaN方法可判断一个数是不是NaN
>double a= Double.NaN;  
System.out.println(Double.isNaN(a));//输出true
  
ps:还有一个方法Double.isInfinite()可判断一个数是不是无穷大(包括正无穷和负无穷),是返回true,否则为false

# 3.3.3char类型
char类型字面量值需要用单引号括起来,如'A'表示字符A(注意双引号"A"表示字符串)  
char类型可表示为十六进制值,范围从\u0000到\uffff,如'\u2122'表示™(\u为转义序列)
|  转义序列  |  名称  |  Unicode值  |  
|:---:|:---:|:---:| 
|\n|换行|\u000a|
|\\"|双引号|\u0022|
|\\'|单引号|\u0027|
|\\\ |反斜杠|\u005c|  

注意，\u转义序列会在解析代码前处理，比如
>System.out.println("\u0022");  

会报错，因为\u0022会先解析成",相当于System.out.println(""")(注意不是System.out.println("\\""))

# 3.3.4 Unicode和char类型
略

# 3.3.5 boolean类型
有true和false,但是整形值不能与boolean型相互转换，如boolean flag=1;会报错  

ps
这样假如一个整形x，我们也不能直接写成if(x)来判断x是否为0,而是写成if(x==0)


